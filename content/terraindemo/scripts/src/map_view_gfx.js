// Generated by CoffeeScript 1.3.3
(function() {
    var local_init = function(params) {
        var game_map = params.map_data;
        var viewport = params.viewport;
        var camera_focus_pos = params.camera_focus_pos;
        var unwinder = params.unwinder;
        var assets = params.assets;
        var tile_size = params.tile_size;
        // information for how the terrain is laid out
        var plane_width = game_map.width * tile_size;
        var plane_height = game_map.height * tile_size;

        // the scene everything will go under.. is this
        // all we want to export?
        var scene = new THREE.Scene();

        // generate the geometry for the terrain
        var geometry = ss0.map_view.gfx.terrain.generate({
            x_size: plane_width,
            y_size: plane_height,
            segmentsW: game_map.width,
            segmentsH: game_map.height,
            game_map: game_map
        });
        unwinder.register_disposable(geometry);
        // generate the texture for the terrain
        var colors = ss0.game.map_util.get_colors(game_map);
        var texture = ss0.map_view.gfx.terrain.generate_texture(
            game_map,
            game_map.width, game_map.height,
            new THREE.Color().setHex(colors.min_color),
            new THREE.Color().setHex(colors.rng_color));
        unwinder.register_disposable(texture);
        var terrain_material = new THREE.ShaderMaterial({
            vertexShader: ss0.map_view.gfx.terrain.shaders.terrain_vertex,
            fragmentShader: ss0.map_view.gfx.terrain.shaders.terrain_fragment,
            uniforms: {
                terrain: { type: "t", value: texture }
            }/*,
               transparent: true
               ,depthWrite: false
             */
        });
        var overlay_material = new THREE.ShaderMaterial({
            vertexShader: ss0.map_view.gfx.terrain.shaders.overlay_vertex,
            fragmentShader: ss0.map_view.gfx.terrain.shaders.overlay_fragment,
            uniforms: {
                highlight_box_red: {type:"v3", value: new THREE.Vector3()},
                highlight_box_yellow: {type:"v3", value: new THREE.Vector3()},
                highlight_box_blue: {type:"v3", value: new THREE.Vector3()},
                box_halfwidth: {type:"f", value: tile_size / 2}
            },
            transparent: true,
            depthWrite: false
        });
        unwinder.register_disposable(terrain_material);
        unwinder.register_disposable(overlay_material);
        // lighting for the scene
        var light = new THREE.AmbientLight( 0x404040 );
        scene.add( light );
        // combine the terrain geometry and texture and
        // add it to the scene
        var terrain_mesh = new THREE.Mesh(geometry, terrain_material);
        terrain_mesh.position = {
            x:plane_width / 2,
            y:0,
            z:plane_height / 2
        };
        scene.add(terrain_mesh);
        var overlay_mesh = new THREE.Mesh(geometry, overlay_material);
        overlay_mesh.position = {
            x:plane_width / 2,
            y:16,
            z:plane_height / 2
        };
        scene.add(overlay_mesh);
        assets.meshes.push(overlay_mesh); 
        // this is all we export, for now.. what if we
        // want to allow terrain deformation or repainting
        // the texture..?
        
        var cameras_state = {
            birds_eye: {
                view_degrees: ss0.game.map_util.facing.NORTH,
                radius: 2800,
                height_offset: 2100,
                position: camera_focus_pos
            }
        };
        // birds-eye camera
        var be_camera_pos = ss0.map_view.gfx.camera.get_radial_pos(
            cameras_state.birds_eye.position,
            cameras_state.birds_eye.radius,
            cameras_state.birds_eye.view_degrees,
            cameras_state.birds_eye.height_offset);
        var be_params = [viewport.x / -2, viewport.x / 2, viewport.y / 2, viewport.y / -2, -4000, 4000];
        var birds_eye = ss0.map_view.gfx.camera.birds_eye_init(be_params, be_camera_pos);
        // actors
        return { 
            tile_size: tile_size,
            cameras: {
                birds_eye: birds_eye
            },
            cameras_state: cameras_state,
            scene: scene,
            meshes: {
                terrain: {
                    base: terrain_mesh,
                    overlay: overlay_mesh
                }
            }
        };
    };
    sugs.namespace.set(this, 'ss0.map_view.gfx', function(gfx){
        gfx.init = local_init;
    });
}).call(this);
